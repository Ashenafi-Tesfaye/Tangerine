<script src="tangy-form-response-model.js"></script>
<link rel="import" href="tangy-form-item.html">
<link rel="import" href="../tangy-timed/tangy-timed.html">

<!-- dependencies -->
<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/paper-tabs/paper-tabs.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/iron-form/iron-form.html">
<link rel="import" href="../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../bower_components/paper-card/paper-card.html">
<link rel="import" href="../../bower_components/paper-checkbox/paper-checkbox.html">
<link rel="import" href="../../bower_components/paper-progress/paper-progress.html">
<link rel="import" href="../../bower_components/paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../../bower_components/paper-listbox/paper-listbox.html">
<link rel="import" href="../../bower_components/paper-item/paper-item.html">
<script src="../../bower_components/pouchdb/dist/pouchdb.js"></script>

<style>
  input:invalid {
    background-color: #ffdddd;
  }
  paper-card {
    margin: 15px 0px;
    padding: 25px;
  }
</style>

<dom-module id="tangy-form">

  <template>

      <style>
        #tangy-form-responses, #tangy-form-questions {
          margin 15px;
          padding: 15px;
        }
        #tangy-form-questions--button-container {
          position: fixed;
          bottom: 15px;
          right: 15px;
        }
        #tangy-form-questions--progress {
          position: fixed;
          bottom: 0px;
          left: 0px;
          width: 100%;
        }
      </style>

      <paper-button on-click='newResponse' raised>New Response</paper-button>
      <paper-tabs selected="0">
        <paper-tab id="tangy-form--show-questions" on-click="showQuestionsPane">QUESTIONS</paper-tab>
        <paper-tab id="tangy-form--show-responses" on-click="showResponsesPane">RESPONSES</paper-tab>
      </paper-tabs>
      <div id="tangy-form-questions">
        <slot id="tangy-form-questions--form"></slot>
        <div id="tangy-form-questions--button-container">
          <paper-button id="tangy-form-questions--back-button" raised on-click="navigationClickListener">< back</paper-button>
          <paper-button id="tangy-form-questions--next-button" raised on-click="navigationClickListener">next ></paper-button>
        </div>
        <paper-progress id="tangy-form-questions--progress" value="0" secondary-progress="100"></paper-progress>
      </div>
      <div id="tangy-form-responses" hidden>
        <paper-button on-click='generateCSV' raised>Download CSV</paper-button>
        <ul>
          <template is="dom-repeat" items="{{responses}}">
            <li> 
              [[item.datetime]]
              <paper-button data-response-id="[[item._id]]" on-click="resumeResponse" raised>resume</paper-button> 
              <template is="dom-if" if="{{item.isCurrentTangyFormResponse}}">
                <span style="color: red"> *</span>
              </template>
            </li>
          </template>
        </ul>
      </div>

  </template>

  <script>
    /**
     * `tangy-form`
     * An element used to encapsulate form elements for multipage forms with a response in PouchDB.
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */

    class TangyForm extends Polymer.Element {

      static get is() { return 'tangy-form'; }
      static get properties() {
        return {
          id: {
            type: String,
            value: 'tangy-form'
          },
          src: {
            type: String,
            value: 'tangy-form'
          },
          database: {
            type: String,
            value: 'tangy-form'
          }
        };
      }

      static set responses(data) {
        return this._responses = data
      }

      static get responses() {
        if (this.hasOwnProperty('_responses')) {
          return this._responses
        }
        else {
          this._responses = []
          return this._responses
        }
      }

      async ready() {
        super.ready();
        // Use a PouchDB to store responses.
        this.db = new PouchDB(this.database)
        // Load responses for responses list.
        this.loadQuestionsPane()
        this.loadResponsesPane()
        this.updateItemNavigation()
      }

      showQuestionsPane() {
        this.$['tangy-form-responses'].hidden = true 
        this.$['tangy-form-questions'].hidden = false
      }

      showResponsesPane() {
        this.$['tangy-form-questions'].hidden = true 
        this.$['tangy-form-responses'].hidden = false 
      }

      async loadQuestionsPane() {
        // Get the current response, else catch and create new response.
        try {
          let currentTangyFormResponse = await this.db.get(`current_tangy_form_response_${this.id}`);
          this.tangyFormResponse = await this.db.get(currentTangyFormResponse.responseId)
        }
        catch(e) {
          // Create a new response document.
          this.tangyFormResponse = new TangyFormResponseModel({ form_id: this.id })
          const dbStatus = await this.db.post(this.tangyFormResponse)
          Object.apply(this.tangyFormResponse, await this.db.get(dbStatus.id))
          // Set response id as the current response.
          await this.db.put({
            _id: `current_tangy_form_response_${this.id}`,
            responseId: this.tangyFormResponse._id 
          })
        }
        // Unload all items and make sure the response has a place for them.
        let items = this.querySelectorAll('tangy-form-item')
        items.forEach((item, index) => {
          item.removeAttribute('load')
          if (!this.tangyFormResponse.items.hasOwnProperty(item.id)) {
            this.tangyFormResponse.items[item.id] = {}
          }
        })
        // Find the first item and load it.
        this.loadItem(items[0].id)
        // @TODO: Resume on the item last viewed? Could get reduxy here.
      }

      async loadResponsesPane() {
        let currentResponse = await this.db.get(`current_tangy_form_response_${this.id}`);
        // @TODO Query for form response docs with `doc.form_id` equal to `this.form_id`.
        let allDocs = (await this.db.allDocs({include_docs: true})).rows.map((row) => { return row.doc})
        allDocs.sort(function (a, b) {
          return b.unixtime - a.unixtime;
        });
        this.responses = allDocs.filter((doc) => {
          if (doc.type === 'tangy-form-response' && doc.form_id == this.id) {
            if (doc._id == currentResponse.responseId) {
              doc.isCurrentTangyFormResponse = true
            } else {
              doc.isCurrentTangyFormResponse = false
            }
            return doc
          }
        }) 
      }

      async loadItem(itemId) {
        let item = this.querySelector(`#${itemId}`)
        // @TODO: This needs to be unbinded.
        item.addEventListener('item-skip', this.itemSkipListener.bind(this), { once: true })
        item.addEventListener('item-loaded', this.itemLoadedListener.bind(this), { once: true })
        item.setAttribute('load', true)
      }

      async unloadItem(itemId, bypassValidation) {
        let item = this.querySelector(`#${itemId}`)
        if (item.load === true) {
          // Make sure we don't currently have invalid input.
          let ironForm = item.querySelector('iron-form')
          if (!bypassValidation && ironForm && !ironForm.validate()) {
            return false
          }
          // Save item into response.
          if (ironForm) {
            Object.assign(this.tangyFormResponse.items[itemId], ironForm.serializeForm())
            await this.db.put(this.tangyFormResponse)
            this.tangyFormResponse = await this.db.get(this.tangyFormResponse._id)
          }
          item.removeAttribute('load')
        }
        return true
      }

      async focusOnItem(itemId) {
        // Find all items loaded and unload them, make sure they do not return false.
        let items = this.querySelectorAll('tangy-form-item')
        for (let item of items) {
          // @TODO: If we don't async this context and await this function, it returns a promise which is 
          // not how I understand await-able things to work.
          if (item.load === true) {
            let unloadItemStatus = await this.unloadItem(item.id, true)
            if (unloadItemStatus === false) {
              // Prevent focus, there is still work to be done.
              return
            }
          }
        }
        // Load item.
        await this.loadItem(itemId)
        this.updateItemNavigation()
      }

      itemSkipListener(event) {
        // Unload all items with bypassValidation
        let items = this.querySelectorAll('tangy-form-item')
        let currentItemIndex = 0
        // Find current item index. Assumes only one item is loaded.
        let i = 0
        for (let item of items) {
          if (item.id == event.currentTarget.id) {
            currentItemIndex = i 
          } else {
            i++
          }
        }
        // Update the next and back buttons.
        this.focusOnItem(items[currentItemIndex+1].id)
      }
        
      itemLoadedListener(event) {
        let item = this.querySelector(`#${event.currentTarget.id}`)
        let inputs = item.querySelectorAll('[name]') 
        let ironForm = item.querySelector('iron-form');
        let htmlForm = item.querySelector('form');
        // Load response data into the item
        for (let input of inputs) {
          if (this.tangyFormResponse.items[item.id].hasOwnProperty(input.name)) {
            // Handle iron elements.
            switch (input.tagName) {
              case 'PAPER-INPUT':
                input.value = this.tangyFormResponse.items[item.id][input.name]
                break
              case 'PAPER-CHECKBOX':
                input.checked = true
                break
              case 'PAPER-DROPDOWN-MENU':
                //input.selected-
                let listBox = input.querySelector('paper-listbox')
                let paperItems = input.querySelectorAll('paper-item')
                // Find index of paper item to select.
                let paperItemIndex = 0
                let i = 0
                for (let paperItem of paperItems) {
                  if (paperItem.innerText == this.tangyFormResponse.items[item.id][input.name]) {
                    paperItemIndex = i
                  }
                  i++
                }
                listBox.selected = paperItemIndex
                break
            }
            // Handle standard form input element.
            switch(input.type) {
              case 'checkbox':
                input.checked = this.tangyFormResponse.items[item.id][input.name]
                break
              case 'radio':
                if (this.tangyFormResponse.items[item.id][input.name] == input.value) {
                  input.checked = true
                }
                break
              default:
                input.value = this.tangyFormResponse.items[item.id][input.name]
            }
            htmlForm.dispatchEvent(new Event('change'), {bubbles: true})
          } 
        }
      }

      updateItemNavigation() {
        let items = this.querySelectorAll('tangy-form-item')
        let currentItemIndex = 0
        // Find current item index. Assumes only one item is loaded.
        let i = 0
        for (let item of items) {
          if (item.load == true) {
            currentItemIndex = i 
          } else {
            i++
          }
        }
        // Update the next and back buttons.
        if (items[currentItemIndex+1]) {
          this.$['tangy-form-questions--next-button'].removeAttribute('disabled')
          this.$['tangy-form-questions--next-button'].setAttribute('data-focus-on-item', items[currentItemIndex+1].id)
        }
        else {
          this.$['tangy-form-questions--next-button'].setAttribute('disabled', true)
        }
        if (items[currentItemIndex-1]) {
          this.$['tangy-form-questions--back-button'].removeAttribute('disabled')
          this.$['tangy-form-questions--back-button'].setAttribute('data-focus-on-item', items[currentItemIndex-1].id)
        }
        else {
          this.$['tangy-form-questions--back-button'].setAttribute('disabled', true)
        }
        // Update progress.
        let progressCalculation = (parseInt(((currentItemIndex+1)/items.length)*100))
        this.$['tangy-form-questions--progress'].setAttribute('value', progressCalculation)
      }

      async navigationClickListener(event) {
        let itemId = event.currentTarget.getAttribute('data-focus-on-item')
        this.focusOnItem(itemId)
      }

      async newResponse() {
        // Create the new response.
        let tangyFormResponse = new TangyFormResponseModel({ form_id: this.id })
        let dbStatus = await this.db.post(tangyFormResponse)
        let currentTangyFormResponse = await this.db.get(`current_tangy_form_response_${this.id}`);
        currentTangyFormResponse.responseId = dbStatus.id
        await this.db.put(currentTangyFormResponse)
        this.loadQuestionsPane()
        this.loadResponsesPane()
      }

      async resumeResponse(event) {
        let currentTangyFormResponse = await this.db.get(`current_tangy_form_response_${this.id}`);
        currentTangyFormResponse.responseId = event.path[0].dataResponseId
        await this.db.put(currentTangyFormResponse)
        this.loadQuestionsPane()
        this.loadResponsesPane()
      }

      generateCSV() {
        let blob = new Blob([], {type: 'application/csv;charset=utf-8;' });
        // TODO: Scan for keys. Bonus points for doing it 100 sessions at a time.
        // Get header row.
        let keys = []
        for (let response of this.responses) {
          keys = _.uniq(keys.concat(Object.getOwnPropertyNames(response)))
        }
        // Get all data row.
        blob = new Blob([blob, keys.join(',') + '\n'], { type: 'application/csv;charset=utf-8;' });
        for (let response of this.responses) {
          let row = []
          // TODO: Loop through keys, assign empty values for nonmatching keys.
          for (let key of keys) {
            if (response.hasOwnProperty(key)) {
              row.push('"' + encodeURI(response[key]) + '"')
            } else {
              row.push('""')
            }
          }
          blob = new Blob([blob, row.join(',') + '\n'], { type: 'application/csv;charset=utf-8;' });
        }
        console.log('creating element');
        const element = window.document.createElement('a');
        element.setAttribute('href', URL.createObjectURL(blob));
        element.setAttribute('download', this.form_id + '.csv');
        console.log('appending to DOM');
        element.style.display = 'none';
        window.document.body.appendChild(element);
        console.log('Triggering download.');
        element.click();
        console.log('Cleaning up.');
        window.document.body.removeChild(element);
      }
    }

    window.customElements.define(TangyForm.is, TangyForm);
  </script>
</dom-module>
